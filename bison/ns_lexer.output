Grammar

    0 $accept: program $end

    1 program: statement

    2 statement: expression_statement
    3          | selection_statement
    4          | labeled_statement
    5          | iteration_statement
    6          | declaration_statement
    7          | jump_statement

    8 labeled_statement: CASE literal COLON statement EOL
    9                  | DEFAULT COLON statement EOL

   10 iteration_statement: WHILE expression OPEN_BRACE statement CLOSE_BRACE EOL
   11                    | DO OPEN_BRACE statement CLOSE_BRACE WHILE expression EOL
   12                    | FOR IDENTIFIER INT TO INT OPEN_BRACE statement CLOSE_BRACE EOL
   13                    | FOR IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL

   14 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE EOL
   15                    | IF expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL
   16                    | SWITCH expression OPEN_BRACE statement CLOSE_BRACE

   17 expression_statement: EOL
   18                     | OPEN_BRACE expression CLOSE_BRACE EOL

   19 declaration_statement: fn_declaration
   20                      | struct_declaration
   21                      | variable_declaration

   22 jump_statement: RETURN expression EOL
   23               | BREAK EOL
   24               | CONTINUE EOL

   25 variable_declaration: type_qualifier IDENTIFIER type_declaration
   26                     | type_qualifier IDENTIFIER type_declaration ASSIGN expression
   27                     | type_qualifier IDENTIFIER type_declaration ASSIGN lambda_declaration

   28 type: I8
   29     | I16
   30     | I32
   31     | I64
   32     | U8
   33     | U16
   34     | U32
   35     | U64
   36     | F32
   37     | F64
   38     | BOOL
   39     | BYTE
   40     | STR
   41     | IDENTIFIER

   42 type_declaration: /* empty */
   43                 | COLON type

   44 type_qualifier: CONST
   45               | LET

   46 assignment_operator: ASSIGN
   47                    | ADD_ASSIGN
   48                    | SUB_ASSIGN
   49                    | MUL_ASSIGN
   50                    | DIV_ASSIGN
   51                    | MOD_ASSIGN
   52                    | BIT_AND_ASSIGN
   53                    | BIT_OR_ASSIGN
   54                    | BIT_XOR_ASSIGN
   55                    | BIT_SHL_ASSIGN
   56                    | BIT_SHR_ASSIGN

   57 conditional_expression: logical_or_expression
   58                       | logical_or_expression QUESTION_MARK expression COLON conditional_expression

   59 logical_or_expression: logical_and_expression
   60                      | logical_or_expression LOGIC_OR logical_and_expression

   61 logical_and_expression: inclusive_or_expression
   62                       | logical_and_expression LOGIC_AND inclusive_or_expression

   63 inclusive_or_expression: exclusive_or_expression
   64                        | inclusive_or_expression OR exclusive_or_expression

   65 exclusive_or_expression: and_expression
   66                        | exclusive_or_expression XOR and_expression

   67 and_expression: equality_expression
   68               | and_expression AND equality_expression

   69 equality_expression: relational_expression
   70                    | equality_expression EQ relational_expression
   71                    | equality_expression NE relational_expression

   72 relational_expression: shift_expression
   73                      | relational_expression LT shift_expression
   74                      | relational_expression GT shift_expression
   75                      | relational_expression LE shift_expression
   76                      | relational_expression GE shift_expression

   77 shift_expression: additive_expression
   78                 | shift_expression SHL additive_expression
   79                 | shift_expression SHR additive_expression

   80 additive_expression: multiplicative_expression
   81                    | additive_expression ADD multiplicative_expression
   82                    | additive_expression SUB multiplicative_expression

   83 multiplicative_expression: unary_expression
   84                          | multiplicative_expression MUL unary_expression
   85                          | multiplicative_expression DIV unary_expression
   86                          | multiplicative_expression MOD unary_expression

   87 unary_expression: postfix_expression
   88                 | unary_operator unary_expression
   89                 | AWAIT unary_expression

   90 unary_operator: AND
   91               | MUL
   92               | ADD
   93               | SUB
   94               | BIT_INV
   95               | NOT

   96 postfix_expression: primary_expression
   97                   | postfix_expression OPEN_PAREN CLOSE_PAREN
   98                   | postfix_expression OPEN_PAREN assignment_expression CLOSE_PAREN
   99                   | postfix_expression OPEN_BRACKET expression CLOSE_BRACKET
  100                   | postfix_expression DOT IDENTIFIER
  101                   | postfix_expression AS type

  102 primary_expression: literal
  103                   | IDENTIFIER
  104                   | OPEN_PAREN expression CLOSE_PAREN

  105 literal: INT
  106        | DOUBLE
  107        | STRING
  108        | TRUE
  109        | FALSE
  110        | NIL

  111 expression: assignment_expression
  112           | expression COMMA assignment_expression

  113 assignment_expression: conditional_expression
  114                      | unary_expression assignment_operator assignment_expression

  115 fn_qualifier: /* empty */
  116             | ASYNC

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN type_declaration IN statement CLOSE_BRACE

  119 parameters: parameters COMMA parameter
  120           | parameter

  121 parameter_qualifier: /* empty */
  122                    | REF

  123 parameter: /* empty */
  124          | parameter_qualifier IDENTIFIER type_declaration

  125 struct_declaration: STRUCT IDENTIFIER OPEN_BRACE struct_fields CLOSE_BRACE EOL

  126 struct_fields: struct_fields EOL struct_field
  127              | struct_field

  128 struct_field: /* empty */
  129             | IDENTIFIER COLON type


Terminals, with rules where they appear

$end (0) 0
error (256)
LET (258) 45
CONST (259) 44
FN (260) 117
REF (261) 122
STRUCT (262) 125
ASYNC (263) 116
AWAIT (264) 89
AS (265) 101
IF (266) 14 15
ELSE (267) 15
DO (268) 11
TO (269) 12
WHILE (270) 10 11
FOR (271) 12 13
IN (272) 13 118
RETURN (273) 22
BREAK (274) 23
CONTINUE (275) 24
TRUE (276) 108
FALSE (277) 109
NIL (278) 110
SWITCH (279) 16
CASE (280) 8
DEFAULT (281) 9
I8 (282) 28
I16 (283) 29
I32 (284) 30
I64 (285) 31
U8 (286) 32
U16 (287) 33
U32 (288) 34
U64 (289) 35
F32 (290) 36
F64 (291) 37
BOOL (292) 38
BYTE (293) 39
STR (294) 40
ADD (295) 81 92
SUB (296) 82 93
MUL (297) 84 91
DIV (298) 85
MOD (299) 86
BIT_INV (300) 94
NOT (301) 95
AND (302) 68 90
OR (303) 64
XOR (304) 66
SHL (305) 78
SHR (306) 79
LOGIC_AND (307) 62
LOGIC_OR (308) 60
EQ (309) 70
NE (310) 71
LT (311) 73
GT (312) 74
LE (313) 75
GE (314) 76
ASSIGN (315) 26 27 46
ADD_ASSIGN (316) 47
SUB_ASSIGN (317) 48
MUL_ASSIGN (318) 49
DIV_ASSIGN (319) 50
MOD_ASSIGN (320) 51
BIT_AND_ASSIGN (321) 52
BIT_OR_ASSIGN (322) 53
BIT_XOR_ASSIGN (323) 54
BIT_SHL_ASSIGN (324) 55
BIT_SHR_ASSIGN (325) 56
OPEN_PAREN (326) 97 98 104 117 118
CLOSE_PAREN (327) 97 98 104 117 118
OPEN_BRACE (328) 10 11 12 13 14 15 16 18 117 118 125
CLOSE_BRACE (329) 10 11 12 13 14 15 16 18 117 118 125
OPEN_BRACKET (330) 99
CLOSE_BRACKET (331) 99
COMMA (332) 112 119
COLON (333) 8 9 43 58 129
QUESTION_MARK (334) 58
DOT (335) 100
EOL (336) 8 9 10 11 12 13 14 15 17 18 22 23 24 117 125 126
IDENTIFIER (337) 12 13 25 26 27 41 100 103 117 124 125 129
STRING (338) 107
INT (339) 12 105
DOUBLE (340) 106


Nonterminals, with rules where they appear

$accept (86)
    on left: 0
program (87)
    on left: 1, on right: 0
statement (88)
    on left: 2 3 4 5 6 7, on right: 1 8 9 10 11 12 13 14 15 16 117
    118
labeled_statement (89)
    on left: 8 9, on right: 4
iteration_statement (90)
    on left: 10 11 12 13, on right: 5
selection_statement (91)
    on left: 14 15 16, on right: 3
expression_statement (92)
    on left: 17 18, on right: 2
declaration_statement (93)
    on left: 19 20 21, on right: 6
jump_statement (94)
    on left: 22 23 24, on right: 7
variable_declaration (95)
    on left: 25 26 27, on right: 21
type (96)
    on left: 28 29 30 31 32 33 34 35 36 37 38 39 40 41,
    on right: 43 101 129
type_declaration (97)
    on left: 42 43, on right: 13 25 26 27 117 118 124
type_qualifier (98)
    on left: 44 45, on right: 25 26 27
assignment_operator (99)
    on left: 46 47 48 49 50 51 52 53 54 55 56, on right: 114
conditional_expression (100)
    on left: 57 58, on right: 58 113
logical_or_expression (101)
    on left: 59 60, on right: 57 58 60
logical_and_expression (102)
    on left: 61 62, on right: 59 60 62
inclusive_or_expression (103)
    on left: 63 64, on right: 61 62 64
exclusive_or_expression (104)
    on left: 65 66, on right: 63 64 66
and_expression (105)
    on left: 67 68, on right: 65 66 68
equality_expression (106)
    on left: 69 70 71, on right: 67 68 70 71
relational_expression (107)
    on left: 72 73 74 75 76, on right: 69 70 71 73 74 75 76
shift_expression (108)
    on left: 77 78 79, on right: 72 73 74 75 76 78 79
additive_expression (109)
    on left: 80 81 82, on right: 77 78 79 81 82
multiplicative_expression (110)
    on left: 83 84 85 86, on right: 80 81 82 84 85 86
unary_expression (111)
    on left: 87 88 89, on right: 83 84 85 86 88 89 114
unary_operator (112)
    on left: 90 91 92 93 94 95, on right: 88
postfix_expression (113)
    on left: 96 97 98 99 100 101, on right: 87 97 98 99 100 101
primary_expression (114)
    on left: 102 103 104, on right: 96
literal (115)
    on left: 105 106 107 108 109 110, on right: 8 102
expression (116)
    on left: 111 112, on right: 10 11 14 15 16 18 22 26 58 99 104 112
assignment_expression (117)
    on left: 113 114, on right: 98 111 112 114
fn_qualifier (118)
    on left: 115 116, on right: 117
fn_declaration (119)
    on left: 117, on right: 19
lambda_declaration (120)
    on left: 118, on right: 27
parameters (121)
    on left: 119 120, on right: 117 118 119
parameter_qualifier (122)
    on left: 121 122, on right: 124
parameter (123)
    on left: 123 124, on right: 119 120
struct_declaration (124)
    on left: 125, on right: 20
struct_fields (125)
    on left: 126 127, on right: 125 126
struct_field (126)
    on left: 128 129, on right: 126 127


state 0

    0 $accept: . program $end

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    program                go to state 17
    statement              go to state 18
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 1

   45 type_qualifier: LET .

    $default  reduce using rule 45 (type_qualifier)


state 2

   44 type_qualifier: CONST .

    $default  reduce using rule 44 (type_qualifier)


state 3

  125 struct_declaration: STRUCT . IDENTIFIER OPEN_BRACE struct_fields CLOSE_BRACE EOL

    IDENTIFIER  shift, and go to state 30


state 4

  116 fn_qualifier: ASYNC .

    $default  reduce using rule 116 (fn_qualifier)


state 5

   14 selection_statement: IF . expression OPEN_BRACE statement CLOSE_BRACE EOL
   15                    | IF . expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 62
    assignment_expression      go to state 63


state 6

   11 iteration_statement: DO . OPEN_BRACE statement CLOSE_BRACE WHILE expression EOL

    OPEN_BRACE  shift, and go to state 64


state 7

   10 iteration_statement: WHILE . expression OPEN_BRACE statement CLOSE_BRACE EOL

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 65
    assignment_expression      go to state 63


state 8

   12 iteration_statement: FOR . IDENTIFIER INT TO INT OPEN_BRACE statement CLOSE_BRACE EOL
   13                    | FOR . IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL

    IDENTIFIER  shift, and go to state 66


state 9

   22 jump_statement: RETURN . expression EOL

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 67
    assignment_expression      go to state 63


state 10

   23 jump_statement: BREAK . EOL

    EOL  shift, and go to state 68


state 11

   24 jump_statement: CONTINUE . EOL

    EOL  shift, and go to state 69


state 12

   16 selection_statement: SWITCH . expression OPEN_BRACE statement CLOSE_BRACE

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 70
    assignment_expression      go to state 63


state 13

    8 labeled_statement: CASE . literal COLON statement EOL

    TRUE    shift, and go to state 32
    FALSE   shift, and go to state 33
    NIL     shift, and go to state 34
    STRING  shift, and go to state 43
    INT     shift, and go to state 44
    DOUBLE  shift, and go to state 45

    literal  go to state 71


state 14

    9 labeled_statement: DEFAULT . COLON statement EOL

    COLON  shift, and go to state 72


state 15

   18 expression_statement: OPEN_BRACE . expression CLOSE_BRACE EOL

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 73
    assignment_expression      go to state 63


state 16

   17 expression_statement: EOL .

    $default  reduce using rule 17 (expression_statement)


state 17

    0 $accept: program . $end

    $end  shift, and go to state 74


state 18

    1 program: statement .

    $default  reduce using rule 1 (program)


state 19

    4 statement: labeled_statement .

    $default  reduce using rule 4 (statement)


state 20

    5 statement: iteration_statement .

    $default  reduce using rule 5 (statement)


state 21

    3 statement: selection_statement .

    $default  reduce using rule 3 (statement)


state 22

    2 statement: expression_statement .

    $default  reduce using rule 2 (statement)


state 23

    6 statement: declaration_statement .

    $default  reduce using rule 6 (statement)


state 24

    7 statement: jump_statement .

    $default  reduce using rule 7 (statement)


state 25

   21 declaration_statement: variable_declaration .

    $default  reduce using rule 21 (declaration_statement)


state 26

   25 variable_declaration: type_qualifier . IDENTIFIER type_declaration
   26                     | type_qualifier . IDENTIFIER type_declaration ASSIGN expression
   27                     | type_qualifier . IDENTIFIER type_declaration ASSIGN lambda_declaration

    IDENTIFIER  shift, and go to state 75


state 27

  117 fn_declaration: fn_qualifier . FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

    FN  shift, and go to state 76


state 28

   19 declaration_statement: fn_declaration .

    $default  reduce using rule 19 (declaration_statement)


state 29

   20 declaration_statement: struct_declaration .

    $default  reduce using rule 20 (declaration_statement)


state 30

  125 struct_declaration: STRUCT IDENTIFIER . OPEN_BRACE struct_fields CLOSE_BRACE EOL

    OPEN_BRACE  shift, and go to state 77


state 31

   89 unary_expression: AWAIT . unary_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    unary_expression    go to state 78
    unary_operator      go to state 58
    postfix_expression  go to state 59
    primary_expression  go to state 60
    literal             go to state 61


state 32

  108 literal: TRUE .

    $default  reduce using rule 108 (literal)


state 33

  109 literal: FALSE .

    $default  reduce using rule 109 (literal)


state 34

  110 literal: NIL .

    $default  reduce using rule 110 (literal)


state 35

   92 unary_operator: ADD .

    $default  reduce using rule 92 (unary_operator)


state 36

   93 unary_operator: SUB .

    $default  reduce using rule 93 (unary_operator)


state 37

   91 unary_operator: MUL .

    $default  reduce using rule 91 (unary_operator)


state 38

   94 unary_operator: BIT_INV .

    $default  reduce using rule 94 (unary_operator)


state 39

   95 unary_operator: NOT .

    $default  reduce using rule 95 (unary_operator)


state 40

   90 unary_operator: AND .

    $default  reduce using rule 90 (unary_operator)


state 41

  104 primary_expression: OPEN_PAREN . expression CLOSE_PAREN

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 79
    assignment_expression      go to state 63


state 42

  103 primary_expression: IDENTIFIER .

    $default  reduce using rule 103 (primary_expression)


state 43

  107 literal: STRING .

    $default  reduce using rule 107 (literal)


state 44

  105 literal: INT .

    $default  reduce using rule 105 (literal)


state 45

  106 literal: DOUBLE .

    $default  reduce using rule 106 (literal)


state 46

  113 assignment_expression: conditional_expression .

    $default  reduce using rule 113 (assignment_expression)


state 47

   57 conditional_expression: logical_or_expression .
   58                       | logical_or_expression . QUESTION_MARK expression COLON conditional_expression
   60 logical_or_expression: logical_or_expression . LOGIC_OR logical_and_expression

    LOGIC_OR       shift, and go to state 80
    QUESTION_MARK  shift, and go to state 81

    $default  reduce using rule 57 (conditional_expression)


state 48

   59 logical_or_expression: logical_and_expression .
   62 logical_and_expression: logical_and_expression . LOGIC_AND inclusive_or_expression

    LOGIC_AND  shift, and go to state 82

    $default  reduce using rule 59 (logical_or_expression)


state 49

   61 logical_and_expression: inclusive_or_expression .
   64 inclusive_or_expression: inclusive_or_expression . OR exclusive_or_expression

    OR  shift, and go to state 83

    $default  reduce using rule 61 (logical_and_expression)


state 50

   63 inclusive_or_expression: exclusive_or_expression .
   66 exclusive_or_expression: exclusive_or_expression . XOR and_expression

    XOR  shift, and go to state 84

    $default  reduce using rule 63 (inclusive_or_expression)


state 51

   65 exclusive_or_expression: and_expression .
   68 and_expression: and_expression . AND equality_expression

    AND  shift, and go to state 85

    $default  reduce using rule 65 (exclusive_or_expression)


state 52

   67 and_expression: equality_expression .
   70 equality_expression: equality_expression . EQ relational_expression
   71                    | equality_expression . NE relational_expression

    EQ  shift, and go to state 86
    NE  shift, and go to state 87

    $default  reduce using rule 67 (and_expression)


state 53

   69 equality_expression: relational_expression .
   73 relational_expression: relational_expression . LT shift_expression
   74                      | relational_expression . GT shift_expression
   75                      | relational_expression . LE shift_expression
   76                      | relational_expression . GE shift_expression

    LT  shift, and go to state 88
    GT  shift, and go to state 89
    LE  shift, and go to state 90
    GE  shift, and go to state 91

    $default  reduce using rule 69 (equality_expression)


state 54

   72 relational_expression: shift_expression .
   78 shift_expression: shift_expression . SHL additive_expression
   79                 | shift_expression . SHR additive_expression

    SHL  shift, and go to state 92
    SHR  shift, and go to state 93

    $default  reduce using rule 72 (relational_expression)


state 55

   77 shift_expression: additive_expression .
   81 additive_expression: additive_expression . ADD multiplicative_expression
   82                    | additive_expression . SUB multiplicative_expression

    ADD  shift, and go to state 94
    SUB  shift, and go to state 95

    $default  reduce using rule 77 (shift_expression)


state 56

   80 additive_expression: multiplicative_expression .
   84 multiplicative_expression: multiplicative_expression . MUL unary_expression
   85                          | multiplicative_expression . DIV unary_expression
   86                          | multiplicative_expression . MOD unary_expression

    MUL  shift, and go to state 96
    DIV  shift, and go to state 97
    MOD  shift, and go to state 98

    $default  reduce using rule 80 (additive_expression)


state 57

   83 multiplicative_expression: unary_expression .
  114 assignment_expression: unary_expression . assignment_operator assignment_expression

    ASSIGN          shift, and go to state 99
    ADD_ASSIGN      shift, and go to state 100
    SUB_ASSIGN      shift, and go to state 101
    MUL_ASSIGN      shift, and go to state 102
    DIV_ASSIGN      shift, and go to state 103
    MOD_ASSIGN      shift, and go to state 104
    BIT_AND_ASSIGN  shift, and go to state 105
    BIT_OR_ASSIGN   shift, and go to state 106
    BIT_XOR_ASSIGN  shift, and go to state 107
    BIT_SHL_ASSIGN  shift, and go to state 108
    BIT_SHR_ASSIGN  shift, and go to state 109

    $default  reduce using rule 83 (multiplicative_expression)

    assignment_operator  go to state 110


state 58

   88 unary_expression: unary_operator . unary_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    unary_expression    go to state 111
    unary_operator      go to state 58
    postfix_expression  go to state 59
    primary_expression  go to state 60
    literal             go to state 61


state 59

   87 unary_expression: postfix_expression .
   97 postfix_expression: postfix_expression . OPEN_PAREN CLOSE_PAREN
   98                   | postfix_expression . OPEN_PAREN assignment_expression CLOSE_PAREN
   99                   | postfix_expression . OPEN_BRACKET expression CLOSE_BRACKET
  100                   | postfix_expression . DOT IDENTIFIER
  101                   | postfix_expression . AS type

    AS            shift, and go to state 112
    OPEN_PAREN    shift, and go to state 113
    OPEN_BRACKET  shift, and go to state 114
    DOT           shift, and go to state 115

    $default  reduce using rule 87 (unary_expression)


state 60

   96 postfix_expression: primary_expression .

    $default  reduce using rule 96 (postfix_expression)


state 61

  102 primary_expression: literal .

    $default  reduce using rule 102 (primary_expression)


state 62

   14 selection_statement: IF expression . OPEN_BRACE statement CLOSE_BRACE EOL
   15                    | IF expression . OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL
  112 expression: expression . COMMA assignment_expression

    OPEN_BRACE  shift, and go to state 116
    COMMA       shift, and go to state 117


state 63

  111 expression: assignment_expression .

    $default  reduce using rule 111 (expression)


state 64

   11 iteration_statement: DO OPEN_BRACE . statement CLOSE_BRACE WHILE expression EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 118
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 65

   10 iteration_statement: WHILE expression . OPEN_BRACE statement CLOSE_BRACE EOL
  112 expression: expression . COMMA assignment_expression

    OPEN_BRACE  shift, and go to state 119
    COMMA       shift, and go to state 117


state 66

   12 iteration_statement: FOR IDENTIFIER . INT TO INT OPEN_BRACE statement CLOSE_BRACE EOL
   13                    | FOR IDENTIFIER . type_declaration IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL

    COLON  shift, and go to state 120
    INT    shift, and go to state 121

    $default  reduce using rule 42 (type_declaration)

    type_declaration  go to state 122


state 67

   22 jump_statement: RETURN expression . EOL
  112 expression: expression . COMMA assignment_expression

    COMMA  shift, and go to state 117
    EOL    shift, and go to state 123


state 68

   23 jump_statement: BREAK EOL .

    $default  reduce using rule 23 (jump_statement)


state 69

   24 jump_statement: CONTINUE EOL .

    $default  reduce using rule 24 (jump_statement)


state 70

   16 selection_statement: SWITCH expression . OPEN_BRACE statement CLOSE_BRACE
  112 expression: expression . COMMA assignment_expression

    OPEN_BRACE  shift, and go to state 124
    COMMA       shift, and go to state 117


state 71

    8 labeled_statement: CASE literal . COLON statement EOL

    COLON  shift, and go to state 125


state 72

    9 labeled_statement: DEFAULT COLON . statement EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 126
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 73

   18 expression_statement: OPEN_BRACE expression . CLOSE_BRACE EOL
  112 expression: expression . COMMA assignment_expression

    CLOSE_BRACE  shift, and go to state 127
    COMMA        shift, and go to state 117


state 74

    0 $accept: program $end .

    $default  accept


state 75

   25 variable_declaration: type_qualifier IDENTIFIER . type_declaration
   26                     | type_qualifier IDENTIFIER . type_declaration ASSIGN expression
   27                     | type_qualifier IDENTIFIER . type_declaration ASSIGN lambda_declaration

    COLON  shift, and go to state 120

    $default  reduce using rule 42 (type_declaration)

    type_declaration  go to state 128


state 76

  117 fn_declaration: fn_qualifier FN . IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

    IDENTIFIER  shift, and go to state 129


state 77

  125 struct_declaration: STRUCT IDENTIFIER OPEN_BRACE . struct_fields CLOSE_BRACE EOL

    IDENTIFIER  shift, and go to state 130

    $default  reduce using rule 128 (struct_field)

    struct_fields  go to state 131
    struct_field   go to state 132


state 78

   89 unary_expression: AWAIT unary_expression .

    $default  reduce using rule 89 (unary_expression)


state 79

  104 primary_expression: OPEN_PAREN expression . CLOSE_PAREN
  112 expression: expression . COMMA assignment_expression

    CLOSE_PAREN  shift, and go to state 133
    COMMA        shift, and go to state 117


state 80

   60 logical_or_expression: logical_or_expression LOGIC_OR . logical_and_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    logical_and_expression     go to state 134
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 81

   58 conditional_expression: logical_or_expression QUESTION_MARK . expression COLON conditional_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 136
    assignment_expression      go to state 63


state 82

   62 logical_and_expression: logical_and_expression LOGIC_AND . inclusive_or_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    inclusive_or_expression    go to state 137
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 83

   64 inclusive_or_expression: inclusive_or_expression OR . exclusive_or_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    exclusive_or_expression    go to state 138
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 84

   66 exclusive_or_expression: exclusive_or_expression XOR . and_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    and_expression             go to state 139
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 85

   68 and_expression: and_expression AND . equality_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    equality_expression        go to state 140
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 86

   70 equality_expression: equality_expression EQ . relational_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    relational_expression      go to state 141
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 87

   71 equality_expression: equality_expression NE . relational_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    relational_expression      go to state 142
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 88

   73 relational_expression: relational_expression LT . shift_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    shift_expression           go to state 143
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 89

   74 relational_expression: relational_expression GT . shift_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    shift_expression           go to state 144
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 90

   75 relational_expression: relational_expression LE . shift_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    shift_expression           go to state 145
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 91

   76 relational_expression: relational_expression GE . shift_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    shift_expression           go to state 146
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 92

   78 shift_expression: shift_expression SHL . additive_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    additive_expression        go to state 147
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 93

   79 shift_expression: shift_expression SHR . additive_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    additive_expression        go to state 148
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 94

   81 additive_expression: additive_expression ADD . multiplicative_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    multiplicative_expression  go to state 149
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 95

   82 additive_expression: additive_expression SUB . multiplicative_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    multiplicative_expression  go to state 150
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 96

   84 multiplicative_expression: multiplicative_expression MUL . unary_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    unary_expression    go to state 151
    unary_operator      go to state 58
    postfix_expression  go to state 59
    primary_expression  go to state 60
    literal             go to state 61


state 97

   85 multiplicative_expression: multiplicative_expression DIV . unary_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    unary_expression    go to state 152
    unary_operator      go to state 58
    postfix_expression  go to state 59
    primary_expression  go to state 60
    literal             go to state 61


state 98

   86 multiplicative_expression: multiplicative_expression MOD . unary_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    unary_expression    go to state 153
    unary_operator      go to state 58
    postfix_expression  go to state 59
    primary_expression  go to state 60
    literal             go to state 61


state 99

   46 assignment_operator: ASSIGN .

    $default  reduce using rule 46 (assignment_operator)


state 100

   47 assignment_operator: ADD_ASSIGN .

    $default  reduce using rule 47 (assignment_operator)


state 101

   48 assignment_operator: SUB_ASSIGN .

    $default  reduce using rule 48 (assignment_operator)


state 102

   49 assignment_operator: MUL_ASSIGN .

    $default  reduce using rule 49 (assignment_operator)


state 103

   50 assignment_operator: DIV_ASSIGN .

    $default  reduce using rule 50 (assignment_operator)


state 104

   51 assignment_operator: MOD_ASSIGN .

    $default  reduce using rule 51 (assignment_operator)


state 105

   52 assignment_operator: BIT_AND_ASSIGN .

    $default  reduce using rule 52 (assignment_operator)


state 106

   53 assignment_operator: BIT_OR_ASSIGN .

    $default  reduce using rule 53 (assignment_operator)


state 107

   54 assignment_operator: BIT_XOR_ASSIGN .

    $default  reduce using rule 54 (assignment_operator)


state 108

   55 assignment_operator: BIT_SHL_ASSIGN .

    $default  reduce using rule 55 (assignment_operator)


state 109

   56 assignment_operator: BIT_SHR_ASSIGN .

    $default  reduce using rule 56 (assignment_operator)


state 110

  114 assignment_expression: unary_expression assignment_operator . assignment_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    assignment_expression      go to state 154


state 111

   88 unary_expression: unary_operator unary_expression .

    $default  reduce using rule 88 (unary_expression)


state 112

  101 postfix_expression: postfix_expression AS . type

    I8          shift, and go to state 155
    I16         shift, and go to state 156
    I32         shift, and go to state 157
    I64         shift, and go to state 158
    U8          shift, and go to state 159
    U16         shift, and go to state 160
    U32         shift, and go to state 161
    U64         shift, and go to state 162
    F32         shift, and go to state 163
    F64         shift, and go to state 164
    BOOL        shift, and go to state 165
    BYTE        shift, and go to state 166
    STR         shift, and go to state 167
    IDENTIFIER  shift, and go to state 168

    type  go to state 169


state 113

   97 postfix_expression: postfix_expression OPEN_PAREN . CLOSE_PAREN
   98                   | postfix_expression OPEN_PAREN . assignment_expression CLOSE_PAREN

    AWAIT        shift, and go to state 31
    TRUE         shift, and go to state 32
    FALSE        shift, and go to state 33
    NIL          shift, and go to state 34
    ADD          shift, and go to state 35
    SUB          shift, and go to state 36
    MUL          shift, and go to state 37
    BIT_INV      shift, and go to state 38
    NOT          shift, and go to state 39
    AND          shift, and go to state 40
    OPEN_PAREN   shift, and go to state 41
    CLOSE_PAREN  shift, and go to state 170
    IDENTIFIER   shift, and go to state 42
    STRING       shift, and go to state 43
    INT          shift, and go to state 44
    DOUBLE       shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    assignment_expression      go to state 171


state 114

   99 postfix_expression: postfix_expression OPEN_BRACKET . expression CLOSE_BRACKET

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 172
    assignment_expression      go to state 63


state 115

  100 postfix_expression: postfix_expression DOT . IDENTIFIER

    IDENTIFIER  shift, and go to state 173


state 116

   14 selection_statement: IF expression OPEN_BRACE . statement CLOSE_BRACE EOL
   15                    | IF expression OPEN_BRACE . statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 174
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 117

  112 expression: expression COMMA . assignment_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    assignment_expression      go to state 175


state 118

   11 iteration_statement: DO OPEN_BRACE statement . CLOSE_BRACE WHILE expression EOL

    CLOSE_BRACE  shift, and go to state 176


state 119

   10 iteration_statement: WHILE expression OPEN_BRACE . statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 177
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 120

   43 type_declaration: COLON . type

    I8          shift, and go to state 155
    I16         shift, and go to state 156
    I32         shift, and go to state 157
    I64         shift, and go to state 158
    U8          shift, and go to state 159
    U16         shift, and go to state 160
    U32         shift, and go to state 161
    U64         shift, and go to state 162
    F32         shift, and go to state 163
    F64         shift, and go to state 164
    BOOL        shift, and go to state 165
    BYTE        shift, and go to state 166
    STR         shift, and go to state 167
    IDENTIFIER  shift, and go to state 168

    type  go to state 178


state 121

   12 iteration_statement: FOR IDENTIFIER INT . TO INT OPEN_BRACE statement CLOSE_BRACE EOL

    TO  shift, and go to state 179


state 122

   13 iteration_statement: FOR IDENTIFIER type_declaration . IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL

    IN  shift, and go to state 180


state 123

   22 jump_statement: RETURN expression EOL .

    $default  reduce using rule 22 (jump_statement)


state 124

   16 selection_statement: SWITCH expression OPEN_BRACE . statement CLOSE_BRACE

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 181
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 125

    8 labeled_statement: CASE literal COLON . statement EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 182
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 126

    9 labeled_statement: DEFAULT COLON statement . EOL

    EOL  shift, and go to state 183


state 127

   18 expression_statement: OPEN_BRACE expression CLOSE_BRACE . EOL

    EOL  shift, and go to state 184


state 128

   25 variable_declaration: type_qualifier IDENTIFIER type_declaration .
   26                     | type_qualifier IDENTIFIER type_declaration . ASSIGN expression
   27                     | type_qualifier IDENTIFIER type_declaration . ASSIGN lambda_declaration

    ASSIGN  shift, and go to state 185

    $default  reduce using rule 25 (variable_declaration)


state 129

  117 fn_declaration: fn_qualifier FN IDENTIFIER . OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

    OPEN_PAREN  shift, and go to state 186


state 130

  129 struct_field: IDENTIFIER . COLON type

    COLON  shift, and go to state 187


state 131

  125 struct_declaration: STRUCT IDENTIFIER OPEN_BRACE struct_fields . CLOSE_BRACE EOL
  126 struct_fields: struct_fields . EOL struct_field

    CLOSE_BRACE  shift, and go to state 188
    EOL          shift, and go to state 189


state 132

  127 struct_fields: struct_field .

    $default  reduce using rule 127 (struct_fields)


state 133

  104 primary_expression: OPEN_PAREN expression CLOSE_PAREN .

    $default  reduce using rule 104 (primary_expression)


state 134

   60 logical_or_expression: logical_or_expression LOGIC_OR logical_and_expression .
   62 logical_and_expression: logical_and_expression . LOGIC_AND inclusive_or_expression

    LOGIC_AND  shift, and go to state 82

    $default  reduce using rule 60 (logical_or_expression)


state 135

   83 multiplicative_expression: unary_expression .

    $default  reduce using rule 83 (multiplicative_expression)


state 136

   58 conditional_expression: logical_or_expression QUESTION_MARK expression . COLON conditional_expression
  112 expression: expression . COMMA assignment_expression

    COMMA  shift, and go to state 117
    COLON  shift, and go to state 190


state 137

   62 logical_and_expression: logical_and_expression LOGIC_AND inclusive_or_expression .
   64 inclusive_or_expression: inclusive_or_expression . OR exclusive_or_expression

    OR  shift, and go to state 83

    $default  reduce using rule 62 (logical_and_expression)


state 138

   64 inclusive_or_expression: inclusive_or_expression OR exclusive_or_expression .
   66 exclusive_or_expression: exclusive_or_expression . XOR and_expression

    XOR  shift, and go to state 84

    $default  reduce using rule 64 (inclusive_or_expression)


state 139

   66 exclusive_or_expression: exclusive_or_expression XOR and_expression .
   68 and_expression: and_expression . AND equality_expression

    AND  shift, and go to state 85

    $default  reduce using rule 66 (exclusive_or_expression)


state 140

   68 and_expression: and_expression AND equality_expression .
   70 equality_expression: equality_expression . EQ relational_expression
   71                    | equality_expression . NE relational_expression

    EQ  shift, and go to state 86
    NE  shift, and go to state 87

    $default  reduce using rule 68 (and_expression)


state 141

   70 equality_expression: equality_expression EQ relational_expression .
   73 relational_expression: relational_expression . LT shift_expression
   74                      | relational_expression . GT shift_expression
   75                      | relational_expression . LE shift_expression
   76                      | relational_expression . GE shift_expression

    LT  shift, and go to state 88
    GT  shift, and go to state 89
    LE  shift, and go to state 90
    GE  shift, and go to state 91

    $default  reduce using rule 70 (equality_expression)


state 142

   71 equality_expression: equality_expression NE relational_expression .
   73 relational_expression: relational_expression . LT shift_expression
   74                      | relational_expression . GT shift_expression
   75                      | relational_expression . LE shift_expression
   76                      | relational_expression . GE shift_expression

    LT  shift, and go to state 88
    GT  shift, and go to state 89
    LE  shift, and go to state 90
    GE  shift, and go to state 91

    $default  reduce using rule 71 (equality_expression)


state 143

   73 relational_expression: relational_expression LT shift_expression .
   78 shift_expression: shift_expression . SHL additive_expression
   79                 | shift_expression . SHR additive_expression

    SHL  shift, and go to state 92
    SHR  shift, and go to state 93

    $default  reduce using rule 73 (relational_expression)


state 144

   74 relational_expression: relational_expression GT shift_expression .
   78 shift_expression: shift_expression . SHL additive_expression
   79                 | shift_expression . SHR additive_expression

    SHL  shift, and go to state 92
    SHR  shift, and go to state 93

    $default  reduce using rule 74 (relational_expression)


state 145

   75 relational_expression: relational_expression LE shift_expression .
   78 shift_expression: shift_expression . SHL additive_expression
   79                 | shift_expression . SHR additive_expression

    SHL  shift, and go to state 92
    SHR  shift, and go to state 93

    $default  reduce using rule 75 (relational_expression)


state 146

   76 relational_expression: relational_expression GE shift_expression .
   78 shift_expression: shift_expression . SHL additive_expression
   79                 | shift_expression . SHR additive_expression

    SHL  shift, and go to state 92
    SHR  shift, and go to state 93

    $default  reduce using rule 76 (relational_expression)


state 147

   78 shift_expression: shift_expression SHL additive_expression .
   81 additive_expression: additive_expression . ADD multiplicative_expression
   82                    | additive_expression . SUB multiplicative_expression

    ADD  shift, and go to state 94
    SUB  shift, and go to state 95

    $default  reduce using rule 78 (shift_expression)


state 148

   79 shift_expression: shift_expression SHR additive_expression .
   81 additive_expression: additive_expression . ADD multiplicative_expression
   82                    | additive_expression . SUB multiplicative_expression

    ADD  shift, and go to state 94
    SUB  shift, and go to state 95

    $default  reduce using rule 79 (shift_expression)


state 149

   81 additive_expression: additive_expression ADD multiplicative_expression .
   84 multiplicative_expression: multiplicative_expression . MUL unary_expression
   85                          | multiplicative_expression . DIV unary_expression
   86                          | multiplicative_expression . MOD unary_expression

    MUL  shift, and go to state 96
    DIV  shift, and go to state 97
    MOD  shift, and go to state 98

    $default  reduce using rule 81 (additive_expression)


state 150

   82 additive_expression: additive_expression SUB multiplicative_expression .
   84 multiplicative_expression: multiplicative_expression . MUL unary_expression
   85                          | multiplicative_expression . DIV unary_expression
   86                          | multiplicative_expression . MOD unary_expression

    MUL  shift, and go to state 96
    DIV  shift, and go to state 97
    MOD  shift, and go to state 98

    $default  reduce using rule 82 (additive_expression)


state 151

   84 multiplicative_expression: multiplicative_expression MUL unary_expression .

    $default  reduce using rule 84 (multiplicative_expression)


state 152

   85 multiplicative_expression: multiplicative_expression DIV unary_expression .

    $default  reduce using rule 85 (multiplicative_expression)


state 153

   86 multiplicative_expression: multiplicative_expression MOD unary_expression .

    $default  reduce using rule 86 (multiplicative_expression)


state 154

  114 assignment_expression: unary_expression assignment_operator assignment_expression .

    $default  reduce using rule 114 (assignment_expression)


state 155

   28 type: I8 .

    $default  reduce using rule 28 (type)


state 156

   29 type: I16 .

    $default  reduce using rule 29 (type)


state 157

   30 type: I32 .

    $default  reduce using rule 30 (type)


state 158

   31 type: I64 .

    $default  reduce using rule 31 (type)


state 159

   32 type: U8 .

    $default  reduce using rule 32 (type)


state 160

   33 type: U16 .

    $default  reduce using rule 33 (type)


state 161

   34 type: U32 .

    $default  reduce using rule 34 (type)


state 162

   35 type: U64 .

    $default  reduce using rule 35 (type)


state 163

   36 type: F32 .

    $default  reduce using rule 36 (type)


state 164

   37 type: F64 .

    $default  reduce using rule 37 (type)


state 165

   38 type: BOOL .

    $default  reduce using rule 38 (type)


state 166

   39 type: BYTE .

    $default  reduce using rule 39 (type)


state 167

   40 type: STR .

    $default  reduce using rule 40 (type)


state 168

   41 type: IDENTIFIER .

    $default  reduce using rule 41 (type)


state 169

  101 postfix_expression: postfix_expression AS type .

    $default  reduce using rule 101 (postfix_expression)


state 170

   97 postfix_expression: postfix_expression OPEN_PAREN CLOSE_PAREN .

    $default  reduce using rule 97 (postfix_expression)


state 171

   98 postfix_expression: postfix_expression OPEN_PAREN assignment_expression . CLOSE_PAREN

    CLOSE_PAREN  shift, and go to state 191


state 172

   99 postfix_expression: postfix_expression OPEN_BRACKET expression . CLOSE_BRACKET
  112 expression: expression . COMMA assignment_expression

    CLOSE_BRACKET  shift, and go to state 192
    COMMA          shift, and go to state 117


state 173

  100 postfix_expression: postfix_expression DOT IDENTIFIER .

    $default  reduce using rule 100 (postfix_expression)


state 174

   14 selection_statement: IF expression OPEN_BRACE statement . CLOSE_BRACE EOL
   15                    | IF expression OPEN_BRACE statement . CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 193


state 175

  112 expression: expression COMMA assignment_expression .

    $default  reduce using rule 112 (expression)


state 176

   11 iteration_statement: DO OPEN_BRACE statement CLOSE_BRACE . WHILE expression EOL

    WHILE  shift, and go to state 194


state 177

   10 iteration_statement: WHILE expression OPEN_BRACE statement . CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 195


state 178

   43 type_declaration: COLON type .

    $default  reduce using rule 43 (type_declaration)


state 179

   12 iteration_statement: FOR IDENTIFIER INT TO . INT OPEN_BRACE statement CLOSE_BRACE EOL

    INT  shift, and go to state 196


state 180

   13 iteration_statement: FOR IDENTIFIER type_declaration IN . IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL

    IDENTIFIER  shift, and go to state 197


state 181

   16 selection_statement: SWITCH expression OPEN_BRACE statement . CLOSE_BRACE

    CLOSE_BRACE  shift, and go to state 198


state 182

    8 labeled_statement: CASE literal COLON statement . EOL

    EOL  shift, and go to state 199


state 183

    9 labeled_statement: DEFAULT COLON statement EOL .

    $default  reduce using rule 9 (labeled_statement)


state 184

   18 expression_statement: OPEN_BRACE expression CLOSE_BRACE EOL .

    $default  reduce using rule 18 (expression_statement)


state 185

   26 variable_declaration: type_qualifier IDENTIFIER type_declaration ASSIGN . expression
   27                     | type_qualifier IDENTIFIER type_declaration ASSIGN . lambda_declaration

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    OPEN_BRACE  shift, and go to state 200
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 201
    assignment_expression      go to state 63
    lambda_declaration         go to state 202


state 186

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN . parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

    REF  shift, and go to state 203

    IDENTIFIER  reduce using rule 121 (parameter_qualifier)
    $default    reduce using rule 123 (parameter)

    parameters           go to state 204
    parameter_qualifier  go to state 205
    parameter            go to state 206


state 187

  129 struct_field: IDENTIFIER COLON . type

    I8          shift, and go to state 155
    I16         shift, and go to state 156
    I32         shift, and go to state 157
    I64         shift, and go to state 158
    U8          shift, and go to state 159
    U16         shift, and go to state 160
    U32         shift, and go to state 161
    U64         shift, and go to state 162
    F32         shift, and go to state 163
    F64         shift, and go to state 164
    BOOL        shift, and go to state 165
    BYTE        shift, and go to state 166
    STR         shift, and go to state 167
    IDENTIFIER  shift, and go to state 168

    type  go to state 207


state 188

  125 struct_declaration: STRUCT IDENTIFIER OPEN_BRACE struct_fields CLOSE_BRACE . EOL

    EOL  shift, and go to state 208


state 189

  126 struct_fields: struct_fields EOL . struct_field

    IDENTIFIER  shift, and go to state 130

    $default  reduce using rule 128 (struct_field)

    struct_field  go to state 209


state 190

   58 conditional_expression: logical_or_expression QUESTION_MARK expression COLON . conditional_expression

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 210
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 135
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61


state 191

   98 postfix_expression: postfix_expression OPEN_PAREN assignment_expression CLOSE_PAREN .

    $default  reduce using rule 98 (postfix_expression)


state 192

   99 postfix_expression: postfix_expression OPEN_BRACKET expression CLOSE_BRACKET .

    $default  reduce using rule 99 (postfix_expression)


state 193

   14 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE . EOL
   15                    | IF expression OPEN_BRACE statement CLOSE_BRACE . ELSE OPEN_BRACE statement CLOSE_BRACE EOL

    ELSE  shift, and go to state 211
    EOL   shift, and go to state 212


state 194

   11 iteration_statement: DO OPEN_BRACE statement CLOSE_BRACE WHILE . expression EOL

    AWAIT       shift, and go to state 31
    TRUE        shift, and go to state 32
    FALSE       shift, and go to state 33
    NIL         shift, and go to state 34
    ADD         shift, and go to state 35
    SUB         shift, and go to state 36
    MUL         shift, and go to state 37
    BIT_INV     shift, and go to state 38
    NOT         shift, and go to state 39
    AND         shift, and go to state 40
    OPEN_PAREN  shift, and go to state 41
    IDENTIFIER  shift, and go to state 42
    STRING      shift, and go to state 43
    INT         shift, and go to state 44
    DOUBLE      shift, and go to state 45

    conditional_expression     go to state 46
    logical_or_expression      go to state 47
    logical_and_expression     go to state 48
    inclusive_or_expression    go to state 49
    exclusive_or_expression    go to state 50
    and_expression             go to state 51
    equality_expression        go to state 52
    relational_expression      go to state 53
    shift_expression           go to state 54
    additive_expression        go to state 55
    multiplicative_expression  go to state 56
    unary_expression           go to state 57
    unary_operator             go to state 58
    postfix_expression         go to state 59
    primary_expression         go to state 60
    literal                    go to state 61
    expression                 go to state 213
    assignment_expression      go to state 63


state 195

   10 iteration_statement: WHILE expression OPEN_BRACE statement CLOSE_BRACE . EOL

    EOL  shift, and go to state 214


state 196

   12 iteration_statement: FOR IDENTIFIER INT TO INT . OPEN_BRACE statement CLOSE_BRACE EOL

    OPEN_BRACE  shift, and go to state 215


state 197

   13 iteration_statement: FOR IDENTIFIER type_declaration IN IDENTIFIER . OPEN_BRACE statement CLOSE_BRACE EOL

    OPEN_BRACE  shift, and go to state 216


state 198

   16 selection_statement: SWITCH expression OPEN_BRACE statement CLOSE_BRACE .

    $default  reduce using rule 16 (selection_statement)


state 199

    8 labeled_statement: CASE literal COLON statement EOL .

    $default  reduce using rule 8 (labeled_statement)


state 200

  118 lambda_declaration: OPEN_BRACE . OPEN_PAREN parameters CLOSE_PAREN type_declaration IN statement CLOSE_BRACE

    OPEN_PAREN  shift, and go to state 217


state 201

   26 variable_declaration: type_qualifier IDENTIFIER type_declaration ASSIGN expression .
  112 expression: expression . COMMA assignment_expression

    COMMA  shift, and go to state 117

    $default  reduce using rule 26 (variable_declaration)


state 202

   27 variable_declaration: type_qualifier IDENTIFIER type_declaration ASSIGN lambda_declaration .

    $default  reduce using rule 27 (variable_declaration)


state 203

  122 parameter_qualifier: REF .

    $default  reduce using rule 122 (parameter_qualifier)


state 204

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters . CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL
  119 parameters: parameters . COMMA parameter

    CLOSE_PAREN  shift, and go to state 218
    COMMA        shift, and go to state 219


state 205

  124 parameter: parameter_qualifier . IDENTIFIER type_declaration

    IDENTIFIER  shift, and go to state 220


state 206

  120 parameters: parameter .

    $default  reduce using rule 120 (parameters)


state 207

  129 struct_field: IDENTIFIER COLON type .

    $default  reduce using rule 129 (struct_field)


state 208

  125 struct_declaration: STRUCT IDENTIFIER OPEN_BRACE struct_fields CLOSE_BRACE EOL .

    $default  reduce using rule 125 (struct_declaration)


state 209

  126 struct_fields: struct_fields EOL struct_field .

    $default  reduce using rule 126 (struct_fields)


state 210

   58 conditional_expression: logical_or_expression QUESTION_MARK expression COLON conditional_expression .

    $default  reduce using rule 58 (conditional_expression)


state 211

   15 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE ELSE . OPEN_BRACE statement CLOSE_BRACE EOL

    OPEN_BRACE  shift, and go to state 221


state 212

   14 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 14 (selection_statement)


state 213

   11 iteration_statement: DO OPEN_BRACE statement CLOSE_BRACE WHILE expression . EOL
  112 expression: expression . COMMA assignment_expression

    COMMA  shift, and go to state 117
    EOL    shift, and go to state 222


state 214

   10 iteration_statement: WHILE expression OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 10 (iteration_statement)


state 215

   12 iteration_statement: FOR IDENTIFIER INT TO INT OPEN_BRACE . statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 223
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 216

   13 iteration_statement: FOR IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE . statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 224
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 217

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN . parameters CLOSE_PAREN type_declaration IN statement CLOSE_BRACE

    REF  shift, and go to state 203

    IDENTIFIER  reduce using rule 121 (parameter_qualifier)
    $default    reduce using rule 123 (parameter)

    parameters           go to state 225
    parameter_qualifier  go to state 205
    parameter            go to state 206


state 218

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN . type_declaration OPEN_BRACE statement CLOSE_BRACE EOL

    COLON  shift, and go to state 120

    $default  reduce using rule 42 (type_declaration)

    type_declaration  go to state 226


state 219

  119 parameters: parameters COMMA . parameter

    REF  shift, and go to state 203

    IDENTIFIER  reduce using rule 121 (parameter_qualifier)
    $default    reduce using rule 123 (parameter)

    parameter_qualifier  go to state 205
    parameter            go to state 227


state 220

  124 parameter: parameter_qualifier IDENTIFIER . type_declaration

    COLON  shift, and go to state 120

    $default  reduce using rule 42 (type_declaration)

    type_declaration  go to state 228


state 221

   15 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE . statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 229
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 222

   11 iteration_statement: DO OPEN_BRACE statement CLOSE_BRACE WHILE expression EOL .

    $default  reduce using rule 11 (iteration_statement)


state 223

   12 iteration_statement: FOR IDENTIFIER INT TO INT OPEN_BRACE statement . CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 230


state 224

   13 iteration_statement: FOR IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE statement . CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 231


state 225

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters . CLOSE_PAREN type_declaration IN statement CLOSE_BRACE
  119 parameters: parameters . COMMA parameter

    CLOSE_PAREN  shift, and go to state 232
    COMMA        shift, and go to state 219


state 226

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration . OPEN_BRACE statement CLOSE_BRACE EOL

    OPEN_BRACE  shift, and go to state 233


state 227

  119 parameters: parameters COMMA parameter .

    $default  reduce using rule 119 (parameters)


state 228

  124 parameter: parameter_qualifier IDENTIFIER type_declaration .

    $default  reduce using rule 124 (parameter)


state 229

   15 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement . CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 234


state 230

   12 iteration_statement: FOR IDENTIFIER INT TO INT OPEN_BRACE statement CLOSE_BRACE . EOL

    EOL  shift, and go to state 235


state 231

   13 iteration_statement: FOR IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE . EOL

    EOL  shift, and go to state 236


state 232

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN . type_declaration IN statement CLOSE_BRACE

    COLON  shift, and go to state 120

    $default  reduce using rule 42 (type_declaration)

    type_declaration  go to state 237


state 233

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE . statement CLOSE_BRACE EOL

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 238
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 234

   15 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE . EOL

    EOL  shift, and go to state 239


state 235

   12 iteration_statement: FOR IDENTIFIER INT TO INT OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 12 (iteration_statement)


state 236

   13 iteration_statement: FOR IDENTIFIER type_declaration IN IDENTIFIER OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 13 (iteration_statement)


state 237

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN type_declaration . IN statement CLOSE_BRACE

    IN  shift, and go to state 240


state 238

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement . CLOSE_BRACE EOL

    CLOSE_BRACE  shift, and go to state 241


state 239

   15 selection_statement: IF expression OPEN_BRACE statement CLOSE_BRACE ELSE OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 15 (selection_statement)


state 240

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN type_declaration IN . statement CLOSE_BRACE

    LET         shift, and go to state 1
    CONST       shift, and go to state 2
    STRUCT      shift, and go to state 3
    ASYNC       shift, and go to state 4
    IF          shift, and go to state 5
    DO          shift, and go to state 6
    WHILE       shift, and go to state 7
    FOR         shift, and go to state 8
    RETURN      shift, and go to state 9
    BREAK       shift, and go to state 10
    CONTINUE    shift, and go to state 11
    SWITCH      shift, and go to state 12
    CASE        shift, and go to state 13
    DEFAULT     shift, and go to state 14
    OPEN_BRACE  shift, and go to state 15
    EOL         shift, and go to state 16

    $default  reduce using rule 115 (fn_qualifier)

    statement              go to state 242
    labeled_statement      go to state 19
    iteration_statement    go to state 20
    selection_statement    go to state 21
    expression_statement   go to state 22
    declaration_statement  go to state 23
    jump_statement         go to state 24
    variable_declaration   go to state 25
    type_qualifier         go to state 26
    fn_qualifier           go to state 27
    fn_declaration         go to state 28
    struct_declaration     go to state 29


state 241

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE . EOL

    EOL  shift, and go to state 243


state 242

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN type_declaration IN statement . CLOSE_BRACE

    CLOSE_BRACE  shift, and go to state 244


state 243

  117 fn_declaration: fn_qualifier FN IDENTIFIER OPEN_PAREN parameters CLOSE_PAREN type_declaration OPEN_BRACE statement CLOSE_BRACE EOL .

    $default  reduce using rule 117 (fn_declaration)


state 244

  118 lambda_declaration: OPEN_BRACE OPEN_PAREN parameters CLOSE_PAREN type_declaration IN statement CLOSE_BRACE .

    $default  reduce using rule 118 (lambda_declaration)
