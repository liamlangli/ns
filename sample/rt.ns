import std
import io

struct simd3 { x: f64, y: f64, z: f64 }
struct ray { origin: simd3, direction: simd3 }
struct hit { t: f64, p: simd3, normal: simd3 }
struct sphere { center: simd3, radius: f64 }

fn ops(+)(lhs: simd3, rhs: simd3): simd3 { return simd3 { x: lhs.x + rhs.x, y: lhs.y + rhs.y, z: lhs.z + rhs.z } }
fn ops(-)(lhs: simd3, rhs: simd3): simd3 { return simd3 { x: lhs.x - rhs.x, y: lhs.y - rhs.y, z: lhs.z - rhs.z } }
fn ops(+)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x + rhs, y: lhs.y + rhs, z: lhs.z + rhs } }
fn ops(-)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x + rhs, y: lhs.y + rhs, z: lhs.z + rhs } }
fn ops(*)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x * rhs, y: lhs.y * rhs, z: lhs.z * rhs } }

fn length(this: simd3): f64 {
    return sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
}

fn dot(lhs: simd3, rhs: simd3): f64 {
    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z
}

fn hit_sphere(r: ray, s: sphere): hit {
    let oc = r.origin - s.center
    let a = dot(r.direction, r.direction)
    let b = 2.0 * dot(oc, r.direction)
    let c = dot(oc, oc) - s.radius * s.radius
    let discriminant = b * b - 4.0 * a * c

    if discriminant < 0.0 {
        return hit { t: -1.0, p: simd3 { x: 0.0, y: 0.0, z: 0.0 }, normal: simd3 { x: 0.0, y: 0.0, z: 0.0 } }
    }

    let t = (-b - sqrt(discriminant)) / (2.0 * a)
    let p = r.origin + r.direction * t
    let normal = (p - s.center) * (1.0 / s.radius)

    return hit { t: t, p: p, normal: normal }
}

fn main() {
    let r = ray {
        origin: simd3 { x: 0.0, y: 0.0, z: 0.0 },
        direction: simd3 { x: 0.0, y: 0.0, z: 1.0 }
    }

    let s = sphere {
        center: simd3 { x: 0.0, y: 0.0, z: 1.0 },
        radius: 0.5
    }

    let image = Image{data: [u8](256 * 256 * 4), width: 256, height: 256, channels: 4}
    let offset = 0

    for i in 0 to 256 {
        for j in 0 to 256 {
            let u = i as f64 / 256.0 - 0.5
            let v = j as f64 / 256.0 - 0.5

            r.direction = simd3 { x: u, y: v, z: 1.0 }
            let h = hit_sphere(r, s)
            offset = (i * 256 + j) * 4
            if h.t > 0.0 {
                let n = h.normal * 128.0 + 128.0
                image.data[offset + 0] = n.x as u8
                image.data[offset + 1] = n.y as u8
                image.data[offset + 2] = n.z as u8
            } else {
                image.data[offset + 0] = 0 as u8
                image.data[offset + 1] = 0 as u8
                image.data[offset + 2] = 0 as u8
            }
            image.data[offset + 3] = 255 as u8
        }
    }
    let path = "bin/output.png"
    io_save_image(path, image)
    print("image saved.")
}