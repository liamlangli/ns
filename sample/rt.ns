import std
import io

struct simd3 { x: f64, y: f64, z: f64 }
struct ray { origin: simd3, direction: simd3 }
struct sphere { center: simd3, radius: f64 }

fn ops(+)(lhs: simd3, rhs: simd3): simd3 { return simd3 { x: lhs.x + rhs.x, y: lhs.y + rhs.y, z: lhs.z + rhs.z } }
fn ops(-)(lhs: simd3, rhs: simd3): simd3 { return simd3 { x: lhs.x - rhs.x, y: lhs.y - rhs.y, z: lhs.z - rhs.z } }
fn ops(+)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x + rhs, y: lhs.y + rhs, z: lhs.z + rhs } }
fn ops(-)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x + rhs, y: lhs.y + rhs, z: lhs.z + rhs } }
fn ops(*)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x * rhs, y: lhs.y * rhs, z: lhs.z * rhs } }
fn ops(/)(lhs: simd3, rhs: f64): simd3 { return simd3 { x: lhs.x / rhs, y: lhs.y / rhs, z: lhs.z / rhs } }

fn length(this: simd3): f64 {
    return sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
}

fn normalize(this: simd3): simd3 {
    let inv = 1.0 / length(this)
    return this * inv
}

fn dot(lhs: simd3, rhs: simd3): f64 {
    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z
}

fn hit_sphere(r: ray, s: sphere): f64 {
    let oc = r.origin - s.center
    let a = dot(r.direction, r.direction)
    let b = 2.0 * dot(oc, r.direction)
    let c = dot(oc, oc) - s.radius * s.radius
    let dt = b * b - 4.0 * a * c

    if dt < 0.0 {
        return -1.0
    }

    let t1 = (-b - sqrt(dt)) / (2.0 * a)
    let t2 = (-b + sqrt(dt)) / (2.0 * a)
    if t1 >= 0.0 {
        return t1
    }

    if t2 >= 0.0 {
        return t2
    }

    return -1.0
}

fn main() {
    let r = ray {
        origin: simd3 { x: 0.0, y: 0.0, z: 0.0 },
        direction: simd3 { x: 0.0, y: 0.0, z: 1.0 }
    }

    let s = sphere {
        center: simd3 { x: 0.0, y: 0.0, z: 10.0 },
        radius: 0.5
    }

    let image = Image{data: [u8](256 * 256 * 4), width: 256, height: 256, channels: 4}
    let offset = 0
    let n = simd3 { x: 0.0, y: 0.0, z: 0.0 }
    let p = simd3 { x: 0.0, y: 0.0, z: 0.0 }

    for i in 0 to 256 {
        for j in 0 to 256 {
            let u = i as f64 / 256.0 - 0.5
            let v = j as f64 / 256.0 - 0.5

            r.direction = simd3 { x: u, y: v, z: -1.0 }
            let t = hit_sphere(r, s)
            p = r.origin + r.direction * t
            n = normalize((p - s.center) / s.radius)

            offset = (i * 256 + j) * 4
            if t < 0.0 {
                image.data[offset + 0] = (n.x * 128.0 + 128.0) as u8
                image.data[offset + 1] = (n.y * 128.0 + 128.0) as u8
                image.data[offset + 2] = (n.z * 128.0 + 128.0) as u8
            } else {
                image.data[offset + 0] = 0 as u8
                image.data[offset + 1] = 0 as u8
                image.data[offset + 2] = 0 as u8
            }
            image.data[offset + 3] = 255 as u8
        }
    }
    let path = "bin/output.png"
    io_save_image(path, image)
    print("image saved.\n")
}